Convert Intel format hex file to Cypress format bootloadable .cyacd file.

.cyacd file format:
    [4-byte SiliconID][1-byte SiliconRev][checksum type]
    The data records have the format:
    [1-byte ArrayID][2-byte RowNumber][2-byte DataLength][N-byte Data][1byte Checksum]
    The Checksum is computed by summing all bytes (excluding the checksum itself) and then taking the 2's complement.

eg:
    Line 518   : ":0200000490600A"
    Recordstart: ":"
    Byte Count : 0x02
    Address    : 0x0000
    Record Type: 0x04
    Data       : "9060" : 0x90 0x60
    Checksum   : 0x0A
    Checksum   
    Calculation: 0x0A = 0x100 ­ (0x02+0x00+0x00+0x04+0x90+0x60)

Fraction of Makefile showing the usage:

    hex:
    	arm-none-eabi-objcopy --gap-fill 0x00 -O ihex -v CY8CKIT-049-41XX_GPIO_Example.org.elf CY8CKIT-049-41XX_GPIO_Example.hex

    BOOTLOADER=./UART_Bootloader.elf
    TSIZE=$(shell arm-none-eabi-size $(BOOTLOADER) | grep $(notdir $(BOOTLOADER)) | awk '{ print $$1 }')
    cyacd:
    	-rm -f CY8CKIT-049-41XX_GPIO_Example_new.cyacd
    	perl ../../hex2cyacd/ihex2cyacd.pl $(TSIZE) 128 CY8CKIT-049-41XX_GPIO_Example.hex CY8CKIT-049-41XX_GPIO_Example_new.cyacd
    	diff CY8CKIT-049-41XX_GPIO_Example_new.cyacd CY8CKIT-049-41XX_GPIO_Example.org.cyacd
    	diff --strip-trailing-cr CY8CKIT-049-41XX_GPIO_Example_new.cyacd CY8CKIT-049-41XX_GPIO_Example.org.cyacd
    flash:
    	../../cybootload_linux/cybootload_linux CY8CKIT-049-41XX_GPIO_Example_new.cyacd

See also makefiles in cysample.linux.

Procedure:
New version now skips bytes corresponding to the bootloader, packs the reset into 128 bytes and ignores if all are zero. 

Intially this was how it all started: 
( later multiple lines were combined, and finally simpler byte packing. I guess this can 
further be simplified into few lines of perl code! : 
	pack all data, skip bootheader, unpack into 128 each, skip if 0s
)

use arm-none-eabi-size to determine text size

    arm-none-eabi-size --format=Berkeley Bootloadable\ Blinking\ LED.elf
    text    data     bss     dec     hex filename
    6464      24    1512    8000    1f40 Bootloadable Blinking LED.elf
Number of rows:
    arm-none-eabi-size --format=Berkeley UART_Bootloader.elf 
    text    data     bss     dec     hex filename
    4456      32    1672    6160    1810 UART_Bootloader.elf

Conversion:
    Bootloader size  = 4456/128 = 34 = 0x22. 
    So skip 34*2 line, ie lines 0-((34*2)-1) lines, since hex file has 64 byte size lines.
    Combine data from next odd and even lines to from combined data. So for every two lines in .hex file ( after the skip), there will be one line in .cyacd. See ihex2cyacd.pl for more details. 
    Row number is incremented for every odd-even line combination after the skip, whose data length is 0x40. 
    Repeat this for every line which has data length of 0x40, and combined data from odd and even lines are not "0". But keep row number incrementing for "0"s lines.
    
update:
	Now takes byte count from first line of hex file and uses that to find out number of lines to combine etc.
	test targets: 
		test1 CY8CKIT-049-41XX_GPIO_Example
		test2 CY8CKIT-049-41XX_PWM_Example
		test3 CY8CKIT-049-41XX_UART_Example
		test4 test/Bootloadable Blinking LED
		test5 test/test, elf from compile on linux ( ../cysample.linux )
